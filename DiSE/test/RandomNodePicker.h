#pragma once

#include <dEnc/Defines.h>
#include <bits/stdc++.h>
#include "util.h"

using namespace osuCrypto;


class RandomNodePicker {
    public:
        u64 n, prime, currGeneratorIdx, nextGeneratedNumIdx;
        std::vector<std::pair<u64, std::vector<u64>>> generators;

        RandomNodePicker(u64 n) {
            this->n = n;
            prime = findNextPrime(n);
            for (u64 i = 1; i <= n; i++) {
                std::vector<u64> generatedNums;
                findGeneratedNums(i, generatedNums);
                if (generatedNums.size() == n)
                    generators.push_back(std::make_pair(i, generatedNums));
            }

            // randomize order of generators used
            // srand(time(NULL));
            // std::random_shuffle(generators.begin(), generators.end());

            currGeneratorIdx = 0;
            nextGeneratedNumIdx = 0;
        }

        u64 nextNode() {
            // pick a node from 0 to n-1 to be rebooted next
            u64 nodeNum = generators[currGeneratorIdx].second[nextGeneratedNumIdx++];
            if (nextGeneratedNumIdx == n) {
                nextGeneratedNumIdx = 0;
                currGeneratorIdx = (currGeneratorIdx + 1) % generators.size();
            }
            return nodeNum;
        }
    
        void findGeneratedNums(u64 i, std::vector<u64>& generatedNums) {
            // fill generatedNums with nums from 1 to n that are generated by i^x % prime. Adjust indices to be in [0, n-1]
            std::set<u64> generatedNumsSet;
            u64 powersOfiModPrime = 1;
            for (u64 x = 0; x < prime; x++) {
                if (generatedNumsSet.find(powersOfiModPrime) == generatedNumsSet.end()) { // element not found in set
                    generatedNumsSet.insert(powersOfiModPrime);
                    if (powersOfiModPrime >= 1 && powersOfiModPrime <= n) {
                        generatedNums.push_back(powersOfiModPrime-1); // convert indices to [0, n-1] range
                    }
                }
                powersOfiModPrime = (powersOfiModPrime * i) % prime; // ab mod p = [(a mod p) (b mod p)] mod p
            }
        }
};